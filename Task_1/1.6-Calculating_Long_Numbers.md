# Длинная арифметика.
**Длинная арифметика** позволяет нам считать сколь угодно большие числа, не упираясь в границы размеров типов данных, также важно заметить, что *длинная арифметика* реализуется не аппаратно, а программно.
## Вычисление длинных чисел в n элементарных типах.
**Длинное число** - абстрактная структура данных представления всевозможных целых чисел в среде исполнителя (ЭВМ), над которой определены те же операции, что и над элементарно представимыми целами числами - *сложение*, *вычитание*, *умножение*, *деление*, *нахождение остатка от деления* и *сравнение*.
**(n)-числа** - те числа, которые требуют не более *n* элементов элементарных типов (цифр) в своём представлении. Например, если за элементарный тип данных для представления на 32-битной архитектуре мы выберем *int*, то *long long*, будут *(2)-числами*. 
## Преимущества в вычислениях. Алгоритм Карацубы.
Классическое умножение в столбик имеет сложность *O(N^2)*. Анатолием Карацубой был изобретен более быстрый алгоритм умножения, он также реализует прицип [разделяй и властвуй](https://github.com/6dba/Circle-of-Geniuses/blob/main/Task_1/1.5-Divide_and_Conquer.md#%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9).
Преимущество его в том, что он позволяет побитово перемножать 2 n-значных числа,также сокращает число операций умножения чисел.
Формула умножения в столбик выглядит так:

![Формула умножения в столбик](https://i.imgur.com/IqhZTOt.png)

Где *T* константа, на единицу больше максимального числа представляемого *(n)-числом*, *x*; *y* элементы элементарного типа (цифра), *N1*; *N2* - множители каждый из которых, представленн в виде суммы *Tx+y*.

Алгоритм Карацубы находит произведение по иной формуле:

![Формула умножения алгоритма Карацубы](https://i.imgur.com/zcQj0rV.png)

Рассмотрим алгоритм на примере произведения чисел 56 и 78, приняв *T* за 10, для того, чтобы получить ответ в десятичной СС, таким образом ранзная степень *T* может определять разряд числа.

![Пример алгоритма](https://i.imgur.com/aTslWXT.png)

Мы уменьшили число операций умножения за счёт увеличения операций сложения.
[Сложность алгоритма](https://github.com/6dba/Circle-of-Geniuses/blob/main/Task_1/1.7-The_Basic_Recursion_Theorem.md#%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0-%D0%BA%D0%B0%D1%80%D0%B0%D1%86%D1%83%D0%B1%D1%8B-%D0%BF%D0%BE-%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B5-%D0%BE-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B8) есть порядка *O(N^(3/2))*, что является оптимальнее чем сложность классического умножения в столбик *O(N^2)*.

Хочется добавить, что наличие большого количества операций сложения и вычитания может приводить к тому, что для малых *(n)* алгоритм Карацубы может исполняться дольше, нежели "школьный" столбик, исходя из этого его обычно используют при достаточно больших значениях *n*.
