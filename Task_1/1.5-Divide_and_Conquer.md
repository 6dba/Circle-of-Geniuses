# Разделяй и Властвуй.
Принцип **разделяй и властвуй (Divide and Сonquer)** осуществляет деление задачи на подзадачи, рекурсивно преодолевая каждую и комбинируя решения. Задачи разбиваются до тех пор, пока не окажутся достаточно простыми, чтобы их можно было решить напрямую.
Наблюдать наглядно данный принцип можно, получая n-ое число Фибоначчи:

![DC](https://i.stack.imgur.com/QBJIj.png "Разделяй и Властвуй на примере чисел Фибоначчи")

Мы видим, что функция вызывает сама себя рекурсивно ровно до тех пор, пока не найдется "элементарное решение". Временная сложность данного подхода порядка **O(2^N)**, что не есть хорошо, поэтому на помощь приходит **Динамическое программирование**.
## Разница между динамическим программированием и принципом разделяй и властвуй.
**Динамическое программирование** - это метод решения проблем с перекрывающимися подзадачами, когда решенные подзадачи повторно используется несколько раз. Применять подход динамического программирования мы можем, тогда, когда имеем рекурсивный алгоритм, который решает одну и ту же подзадачу снова и снова, а не генерирует новые. Каждая подзадача решается только один раз, и результат каждой подзадачи сохраняется в таблице. Эти подрешения могут использоваться для получения исходного решения, а метод сохранения решений подзадач известен как **мемоизация**.
Подход динамического программирования расширяет подход разделяй и властвуй с помощью двух методов: **мемоизации** и **табуляции**, цель которых заключается в хранении и повторном использовании решений подзадач, которые могут значительно улучшить производительность.
Таким образом можем определить, что:
- **Мемоизация** (заполнение кэша сверху вниз) относится к технике кэширования и повторного использования ранее вычисленных результатов.
- **Табулирование** (заполнение кеша снизу вверх) аналогично, но фокусируется на первостепенном заполнении записей кеша. Вычисление значений в кеше проще всего выполнять итеративно.
Таким образом можем реализовать подход динамического программирования, также получая n-ое число Фибоначчи:

![DP](https://i.stack.imgur.com/rFqdb.png "Динамическое программирование на примере чисел Фибоначчи")

Временная сложность подхода с использованием мемоизации порядка **O(N)**.
Основная идея, заключается в том, что пока наша проблема разделяй и властвуй имеет перекрывающиеся подзадачи, становится возможным кеширование решений подзадач и, таким образом, могут быть применимы мемоизация / табуляция.
Все вышеупомянутое можно обьединить в одну картинку:

![DPDC](https://cdn-images-1.medium.com/max/2000/1*BwuDAdImyK_nZpb-H8h3SA.jpeg "DPDC")

[Источнк](https://stackoverflow.com/questions/13538459/difference-between-divide-and-conquer-algo-and-dynamic-programming "Источнк")
