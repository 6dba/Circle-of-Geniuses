# Разделяй и властвуй.
Принцип **разделяй и властвуй** (Divide and Сonquer) осуществляет деление задачи на подзадачи, рекурсивно преодолевая каждую и комбинируя решения. Задачи разбиваются до тех пор, пока не окажутся достаточно простыми, чтобы их можно было решить напрямую.
Наблюдать наглядно данный принцип можно, получая n-ое число Фибоначчи:

![DC](https://i.stack.imgur.com/QBJIj.png "Разделяй и Властвуй на примере чисел Фибоначчи")

Мы видим, что функция вызывает сама себя рекурсивно ровно до тех пор, пока не найдется "элементарное решение". Временная сложность данного подхода порядка **O(2^N)**, что не есть хорошо, поэтому на помощь приходит **динамическое программирование**.
## Разница между динамическим программированием и принципом разделяй и властвуй.
**Динамическое программирование** - это метод решения проблем с перекрывающимися подзадачами, когда решенные подзадачи повторно используется несколько раз. Применять подход динамического программирования мы можем, тогда, когда имеем рекурсивный алгоритм, который решает одну и ту же подзадачу снова и снова, а не генерирует новые. Каждая подзадача решается только один раз, и результат каждой подзадачи сохраняется в таблице. Эти подрешения могут использоваться для получения исходного решения, а метод сохранения решений подзадач известен как **мемоизация**.
Подход динамического программирования расширяет подход разделяй и властвуй с помощью двух методов: **мемоизации** и **табуляции**, цель которых заключается в хранении и повторном использовании решений подзадач, которые могут значительно улучшить производительность.
Таким образом можем определить, что:
- **Мемоизация** (заполнение кэша сверху вниз) относится к технике кэширования и повторного использования ранее вычисленных результатов.
- **Табулирование** (заполнение кеша снизу вверх) аналогично, но фокусируется на первостепенном заполнении записей кеша. Вычисление значений в кеше проще всего выполнять итеративно.
Таким образом можем реализовать подход динамического программирования, также получая n-ое число Фибоначчи:

![DP](https://i.stack.imgur.com/rFqdb.png "Динамическое программирование на примере чисел Фибоначчи")

Временная сложность подхода с использованием мемоизации порядка **O(N)**.
Основная идея, заключается в том, что пока наша проблема разделяй и властвуй имеет перекрывающиеся подзадачи, становится возможным кеширование решений подзадач и, таким образом, могут быть применимы мемоизация / табуляция.
Все вышеупомянутое можно обьединить в одну картинку:

![DPDC](https://cdn-images-1.medium.com/max/2000/1*BwuDAdImyK_nZpb-H8h3SA.jpeg "DPDC")

### Индуктивность в программировании 
**Индуктивность** - есть процесс использования результата вычислений некой функции с использованием предыдущих (n-1) параметров, для упрощения результата вычислений текущих (n) значений (Текущий (n) результат может быть такой же, наша выгода в том, что мы не производим вычисления каждый раз заново, то есть использование предыдущих результатов). Инструменты с помощью которых она реализуется есть **мемоизация** и **табуляция**.

### Индуктивность в математике
Разделим алгоритм на две части, дадим частям данного алгоритма на вход один данные, при обьенинении промежуточных результатов каждого из разделенных - итоговый результат будет идентичен. Это есть индуктивность, если мы вытаскиваем какую-то часть алгоритма - логика (структура) сохраняется.

[Источнк](https://stackoverflow.com/questions/13538459/difference-between-divide-and-conquer-algo-and-dynamic-programming "Источнк")
