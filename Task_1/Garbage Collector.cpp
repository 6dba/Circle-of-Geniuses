#include <cstdio>
#include <cstdlib>


// Максимальный размер стека обьектов
constexpr int STACK_MAX_SIZE = 128;

// Кол-во обьектов, после которых вызывается GC
constexpr int MAX_OBJECTS = 10;

// Тип(ы) данных псевдообьектов
typedef enum class Type {
    INT
};


// Обьект непосредственно
typedef struct Object {
    
    Type type;
    int data;
    bool tag; // Флаг обхода

    Object* next; // Указатель на следующий узел (обьект)
};


// Непосредственно 'МАШИНА'
typedef struct Session {

    Object* stack[STACK_MAX_SIZE]; // Стек обьектов
    int size; // Размер текущего стека сессии

    int obj_count;
    int obj_max;

    Object* first;
};


// Добавление обьекта в стек
void push_object(Session* S, Object* obj) {

    S->stack[S->size++] = obj; // Инкрементируем размер, помещаем обьект
}


// Выделение памяти, начальная инициализация
Session* new_session() {

    Session* S = (Session*)malloc(sizeof(Session));
    S->size = NULL;
    S->first = NULL;
    S->obj_count = NULL;
    S->obj_max = MAX_OBJECTS;

    return S;
}


// Пометка обьекта
void mark(Object* obj) {

    if (obj->tag) return;

    obj->tag = true;
}


// Запуск процесса пометки всех доступых обьектов
void mark_all(Session* S) {

    int size = (S->size > S->obj_max) ? S->obj_max : S->size; // Если в программе обьектов больше макисмума - оставляем только максимальный пул обьектов

    for (int i = 0; i < size; i++)
    {
        mark(S->stack[i]); 
    }
}


// Процесс удаления недостижимых обьектов
void clear(Session* S) {

    Object** obj = &S->first; // Инициализируем указатель адресом указателя на обьект
    
    while (*obj) { // Пока существует указатель на обьект (т.е. адрес обьекта)
        if (!(*obj)->tag) {
            Object* unreached = *obj; // Разыменуем и если tag обьекта не помечен как true, то копируем адрес обьекта в новый обьект
            *obj = unreached->next; // Переходим к следующему обьекту, сохраняя его адрес, также высвобождаем предыдущий
            free(unreached);

            S->obj_count--;
        }
        else {
            (*obj)->tag = false; // Иначе "обнуляем" tag обьекта, мол осмотр в этом цикле пройден
            *obj = (*obj)->next; // Переходим к следующему
        }
    }
 }


// Сборщик мусора
void GC(Session* S) {

    int obj_count = S->obj_count; // Фиксируем кол-во обьектов на начало "чистки"

    mark_all(S); // Помечаем все доступные обьекты
    clear(S); // Очищаем непомеченный обьекты

    // S->obj_max = S->obj_count * 2; // Позволяет увеличивать кол-во допустимых обьектов

    printf("Deleted %d objects, %d alive. \n", obj_count - S->obj_count, S->obj_count);
}


// Создание обьекта, начальная инициализация
Object* new_object(Session* S, Type type) {

    if (S->obj_count == S->obj_max) return nullptr; // Если достигнут лимит по обьектам в программе - возвращаем nullptr -> обьект не создается

    Object* obj = (Object*)malloc(sizeof(Object)); // Выделение памяти под обьект
    obj->type = type;
    obj->tag = false;

    obj->next = S->first; // Следующим у свежесозданного обьекта становится предыдущий
    S->first = obj; // Соотсветсвенно первым становится свежесозданный. Грубо говоря получается односвязный список, при создании обьекты выстраивают "связь"
    S->obj_count++;

    return obj;
}


// Создание и добавление обьекта в стек
void push(Session* S, int value) {

    Object* obj = new_object(S, Type::INT);
    if (obj) {
        obj->data = value;
        push_object(S, obj);
    }
}


// Извлечение верхнего элемента
Object* pop(Session* S) {
    if (S->size)
        return S->stack[--S->size]; // Псевдоудаление - мы уменьшаем size, т.е. уменьшается зона видимости, но физически обьект, до сборки мусора еще в стеке
    else return nullptr;
}


// Печать обьектов стека
void print(Session* S) {

    for (int i = 0; i < S->size; i++)
    {
        printf("Object #%d, data: %d\n", i, S->stack[i]->data);
    }
}


// Завершение сессии, принудительно удаление обьектов, высвобождение ресурсов
void shutdown(Session* S) {
    S->size = NULL;
    GC(S);
    free(S);
}


int main()
{
    Session *S = new_session();

    const int PUSH_COUNT = 5;
    const int POP_COUNT = 7;

    for (int i = 0; i < PUSH_COUNT; i++)
    {
        push(S, rand());
    }

    printf("%d objects are created\n\n", PUSH_COUNT);
    print(S);
    
    for (int i = 0; i < POP_COUNT; i++)
    {
        pop(S);
    }
    
    printf("\n%d objects are popped\n\n", POP_COUNT);
    print(S);
    
    printf("\nShutdown Session\n\n");
    shutdown(S);

    return 0;
}

// Идея сие сборщика мусора состоит в том, что мы грубо говоря создаем виртуальную сессию со своими обьектами и своей структурой. 
// Принцип работы сборщика основан на MarkSweep (Пометить - подмести)

// При создании обьекты связываются друг с другом, сохраняя адрес другого в атрибуте Object->next и так по мере работы программы, у нас получается односвязный список обьектов 
// Но связь обьектов "стоит" как бы обособленно, весь пул актуальных обьектов храниться в Session->stack[]
// Таким образом при удалении обьекта (уменьшении размера, т.е. уменьшении "зоны видимости") из стека, сессия уже не сможет обнаружить обьект в актуальных
// (хотя физически он все еще расположен в стеке, но из-за того, что мы уменьшаем size, получить доступ не удается)

// Для удаления таких обьектов нам и понадобилась обособленная их связь
// Когда мы "помечаем" обьекты, мы обходим только лишь актуальный стек обьектов, а удаленные из стека обьекты остаются вне "зоны видимости" и остаются "непомеченными"

// Мы используем это свойство, когда запускаем сборщик мусора (GC()), находя абсолютно все обьекты сессии по связи, созданной между обьектами в процессе их инициализации
// И если рассмотренный обьект не имеет флага (Object->tag != true), то мы можем смело считать, что в акутальном стеке этого обьекта нет и можем удалять его
// Затем берем из этого обьекта адрес следующего и повтоярем действия до тех пор, пока не дойдем до "конца" (пока адрес следующего обьекта не будет NULL)

// В примере  main() мы полностью освобождаем стек 
// (в функции shutdown(), обозначая size как NULL или функции pop() уменьшая size, как следствие обьекты просто не могут быть отмечены)
// но подразумевается то, что в процессе работы потенциальной программы
// С некоторыми обьектами связь будет потеряна и идея их очистки будет соотвествовать вышеописанной


// Принцип работы указателя на указатель можно разобрать здесь: https://gist.github.com/6dba/ceb7e930f5b323f455a4d39b302951fc
